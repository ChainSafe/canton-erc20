module Bridge.Script where

import Daml.Script
import Common.Types
import CIP56.Token
import Bridge.Contracts

-- Test bridge flow using issuer-centric model:
-- EVM deposit → Issuer mints → Issuer initiates withdrawal → EVM release
-- 
-- In the issuer-centric model:
-- - ISSUER controls all operations (no user signatures needed)
-- - Users do NOT manage Canton keys
-- - Issuer mints/burns on behalf of users
testBridgeFlow : Script ()
testBridgeFlow = script do
  -- Allocate parties
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"

  -- Create token manager with extended metadata
  let meta = ExtendedMetadata with
        name = "USD Coin"
        symbol = "USDC"
        decimals = 6
        isin = Some "US1234567890"
        dtiCode = Some "DTI-USDC"
        regulatoryInfo = Some "SEC Registered"

  tokenManagerCid <- submit issuer $ createCmd CIP56Manager with
    issuer = issuer
    meta = meta

  -- ==========================================================================
  -- DEPOSIT FLOW: EVM → Canton (Issuer-Centric)
  -- ==========================================================================
  -- 1. User deposits on EVM with their fingerprint
  -- 2. Middleware detects event, issuer creates MintCommand
  -- 3. Issuer executes mint directly (no user acceptance needed)
  
  let evmTxHash = "0xabc123def456"
  let fingerprint = "1220abc123def456789"  -- User's Canton fingerprint

  -- Issuer creates mint command (after resolving fingerprint → alice)
  mintCmdCid <- submit issuer $ createCmd MintCommand with
    issuer = issuer
    recipient = alice
    tokenManagerCid = tokenManagerCid
    amount = 1000.0
    evmTxHash = evmTxHash
    fingerprint = fingerprint

  -- Issuer executes the mint
  holdingCid <- submit issuer $ exerciseCmd mintCmdCid ExecuteMint

  -- Verify Alice received the tokens
  Some holding <- queryContractId alice holdingCid
  assertMsg "Alice owns tokens" (holding.owner == alice)
  assertMsg "Amount is correct" (holding.amount == 1000.0)

  debug ">>> Deposit flow complete: Alice has 1000.0 tokens"

  -- ==========================================================================
  -- WITHDRAWAL FLOW: Canton → EVM (Issuer-Centric)
  -- ==========================================================================
  -- 1. User requests withdrawal off-chain (via API/UI)
  -- 2. Issuer creates WithdrawalRequest on their behalf
  -- 3. Issuer processes withdrawal (burns tokens, creates event)
  -- 4. Middleware processes WithdrawalEvent → releases on EVM
  
  let evmDestination = EvmAddress "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"
  
  -- Issuer creates withdrawal request on behalf of user
  withdrawalReqCid <- submit issuer $ createCmd WithdrawalRequest with
    issuer = issuer
    userParty = alice
    tokenManagerCid = tokenManagerCid
    holdingCid = holdingCid
    amount = 500.0
    evmDestination = evmDestination
    fingerprint = fingerprint

  -- Issuer processes the withdrawal (burns tokens, creates event)
  withdrawalEventCid <- submit issuer $ exerciseCmd withdrawalReqCid ProcessWithdrawal

  -- Verify WithdrawalEvent was created with Pending status
  Some withdrawalEvent <- queryContractId alice withdrawalEventCid
  assertMsg "Withdrawal amount correct" (withdrawalEvent.amount == 500.0)
  assertMsg "Withdrawal status is Pending" (withdrawalEvent.status == Pending)

  debug ">>> Withdrawal initiated: 500.0 tokens pending release on EVM"

  -- Simulate middleware completing the withdrawal after EVM release
  completedEventCid <- submit issuer $ exerciseCmd withdrawalEventCid CompleteWithdrawal with
    evmTxHash = "0xdef789abc123"

  Some completedEvent <- queryContractId alice completedEventCid
  case completedEvent.status of
    Completed txHash -> assertMsg "EVM tx hash recorded" (txHash == "0xdef789abc123")
    _ -> fail "Expected Completed status"

  debug ">>> Withdrawal completed on EVM"
  debug "✓ Bridge flow test completed successfully!"
  pure ()

-- Test basic CIP56 token operations without bridge
testBasicToken : Script ()
testBasicToken = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"

  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None

  -- Create token manager
  tokenManagerCid <- submit issuer $ createCmd CIP56Manager with
    issuer = issuer
    meta = meta

  -- Mint tokens to Alice
  aliceHoldingCid <- submit issuer $ exerciseCmd tokenManagerCid Mint with
    to = alice
    amount = 500.0

  -- Verify Alice's balance
  Some aliceHolding <- queryContractId alice aliceHoldingCid
  assertMsg "Alice has correct amount" (aliceHolding.amount == 500.0)

  -- Alice transfers to Bob
  (bobHoldingCid, maybeChange) <- submit alice $ exerciseCmd aliceHoldingCid Transfer with
    to = bob
    value = 200.0
    complianceRulesCid = None
    complianceProofCid = None

  -- Verify Bob received tokens
  Some bobHolding <- queryContractId bob bobHoldingCid
  assertMsg "Bob has correct amount" (bobHolding.amount == 200.0)

  -- Verify Alice has change
  case maybeChange of
    Some changeCid -> do
      Some change <- queryContractId alice changeCid
      assertMsg "Alice has correct change" (change.amount == 300.0)
    None -> fail "Expected Alice to have change"

  debug "✓ Basic token test completed successfully!"
  pure ()
