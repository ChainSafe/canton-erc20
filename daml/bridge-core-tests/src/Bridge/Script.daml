module Bridge.Script where

import Daml.Script
import DA.Time (time)
import DA.Date (date, Month(..))
import qualified DA.TextMap as TM
import Common.Types
import Splice.Api.Token.MetadataV1 (Metadata(..))
import Splice.Api.Token.HoldingV1 (InstrumentId(..))
import CIP56.Token
import CIP56.Config
import Bridge.Contracts

testInstrumentId : Party -> InstrumentId
testInstrumentId admin = InstrumentId with admin, id = "USDC"

testMeta : Metadata
testMeta = Metadata with
  values = TM.fromList
    [ ("splice.chainsafe.io/name", "USD Coin")
    , ("splice.chainsafe.io/symbol", "USDC")
    , ("splice.chainsafe.io/decimals", "6")
    ]

testBridgeFlow : Script ()
testBridgeFlow = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  auditor <- allocateParty "Auditor"

  let instrumentId = testInstrumentId issuer

  tokenManagerCid <- submit issuer $ createCmd CIP56Manager with
    issuer = issuer
    instrumentId
    meta = testMeta

  tokenConfigCid <- submit issuer $ createCmd TokenConfig with
    issuer = issuer
    tokenManagerCid = tokenManagerCid
    instrumentId
    meta = testMeta
    auditObservers = [auditor]

  let evmTxHash = "0xabc123def456"
  let fingerprint = "1220abc123def456789"
  let testTime = time (date 2025 Jan 15) 12 0 0

  mintCmdCid <- submit issuer $ createCmd MintCommand with
    issuer = issuer
    recipient = alice
    tokenConfigCid = tokenConfigCid
    amount = 1000.0
    evmTxHash = evmTxHash
    fingerprint = fingerprint
    tokenSymbol = "USDC"
    auditObservers = [auditor]

  (holdingCid, mintEventCid) <- submit issuer $ exerciseCmd mintCmdCid ExecuteMint with
    timestamp = testTime

  Some holding <- queryContractId alice holdingCid
  assertMsg "Alice owns tokens" (holding.owner == alice)
  assertMsg "Amount is correct" (holding.amount == 1000.0)
  assertMsg "InstrumentId correct" (holding.instrumentId == instrumentId)

  Some mintEvent <- queryContractId issuer mintEventCid
  assertMsg "Mint event amount correct" (mintEvent.amount == 1000.0)
  assertMsg "Mint event recipient correct" (mintEvent.recipient == alice)
  assertMsg "Mint event evmTxHash correct" (mintEvent.evmTxHash == Some evmTxHash)

  debug ">>> Deposit flow complete"

  let evmDestination = EvmAddress "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"
  let withdrawalTime = time (date 2025 Jan 15) 14 0 0

  withdrawalReqCid <- submit issuer $ createCmd WithdrawalRequest with
    issuer = issuer
    userParty = alice
    tokenConfigCid = tokenConfigCid
    holdingCid = holdingCid
    amount = 500.0
    evmDestination = evmDestination
    fingerprint = fingerprint
    tokenSymbol = "USDC"
    auditObservers = [auditor]

  (withdrawalEventCid, burnEventCid) <- submit issuer $ exerciseCmd withdrawalReqCid ProcessWithdrawal with
    timestamp = withdrawalTime

  Some withdrawalEvent <- queryContractId alice withdrawalEventCid
  assertMsg "Withdrawal amount correct" (withdrawalEvent.amount == 500.0)
  assertMsg "Withdrawal status is Pending" (withdrawalEvent.status == Pending)

  Some burnEvent <- queryContractId issuer burnEventCid
  assertMsg "Burn event amount correct" (burnEvent.amount == 500.0)
  assertMsg "Burn event evmDestination set" (burnEvent.evmDestination == Some evmDestination.value)

  debug ">>> Withdrawal initiated"

  completedEventCid <- submit issuer $ exerciseCmd withdrawalEventCid CompleteWithdrawal with
    evmTxHash = "0xdef789abc123"

  Some completedEvent <- queryContractId alice completedEventCid
  case completedEvent.status of
    Completed txHash -> assertMsg "EVM tx hash recorded" (txHash == "0xdef789abc123")
    _ -> fail "Expected Completed status"

  debug "Bridge flow test passed!"
  pure ()

testAuditObserverVisibility : Script ()
testAuditObserverVisibility = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  auditor1 <- allocateParty "Auditor1"
  auditor2 <- allocateParty "Auditor2"

  let instrumentId = testInstrumentId issuer

  tokenManagerCid <- submit issuer $ createCmd CIP56Manager with
    issuer = issuer
    instrumentId
    meta = testMeta

  tokenConfigCid <- submit issuer $ createCmd TokenConfig with
    issuer = issuer
    tokenManagerCid = tokenManagerCid
    instrumentId
    meta = testMeta
    auditObservers = [auditor1, auditor2]

  let testTime = time (date 2025 Jan 15) 12 0 0

  mintCmdCid <- submit issuer $ createCmd MintCommand with
    issuer = issuer
    recipient = alice
    tokenConfigCid = tokenConfigCid
    amount = 500.0
    evmTxHash = "0xauditTest"
    fingerprint = "0xAliceFingerprint"
    tokenSymbol = "USDC"
    auditObservers = [auditor1, auditor2]

  (_, mintEventCid) <- submit issuer $ exerciseCmd mintCmdCid ExecuteMint with
    timestamp = testTime

  Some e1 <- queryContractId auditor1 mintEventCid
  assertMsg "Auditor1 sees event" (e1.amount == 500.0)

  Some e2 <- queryContractId auditor2 mintEventCid
  assertMsg "Auditor2 sees event" (e2.amount == 500.0)

  debug "Audit observer visibility test passed!"
  pure ()

testPartialBurnWithAuditEvent : Script ()
testPartialBurnWithAuditEvent = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  auditor <- allocateParty "Auditor"

  let instrumentId = testInstrumentId issuer

  tokenManagerCid <- submit issuer $ createCmd CIP56Manager with
    issuer = issuer
    instrumentId
    meta = testMeta

  tokenConfigCid <- submit issuer $ createCmd TokenConfig with
    issuer = issuer
    tokenManagerCid = tokenManagerCid
    instrumentId
    meta = testMeta
    auditObservers = [auditor]

  let mintTime = time (date 2025 Jan 15) 12 0 0
  let burnTime = time (date 2025 Jan 15) 14 0 0

  mintCmdCid <- submit issuer $ createCmd MintCommand with
    issuer = issuer
    recipient = alice
    tokenConfigCid = tokenConfigCid
    amount = 1000.0
    evmTxHash = "0xMintTx"
    fingerprint = "0xAliceFingerprint"
    tokenSymbol = "USDC"
    auditObservers = [auditor]

  (holdingCid, _) <- submit issuer $ exerciseCmd mintCmdCid ExecuteMint with
    timestamp = mintTime

  let evmDestination = EvmAddress "0xAliceEthWallet"

  withdrawalReqCid <- submit issuer $ createCmd WithdrawalRequest with
    issuer = issuer
    userParty = alice
    tokenConfigCid = tokenConfigCid
    holdingCid = holdingCid
    amount = 400.0
    evmDestination = evmDestination
    fingerprint = "0xAliceFingerprint"
    tokenSymbol = "USDC"
    auditObservers = [auditor]

  (_, burnEventCid) <- submit issuer $ exerciseCmd withdrawalReqCid ProcessWithdrawal with
    timestamp = burnTime

  Some burnEvent <- queryContractId issuer burnEventCid
  assertMsg "Burn amount correct" (burnEvent.amount == 400.0)

  case burnEvent.remainderCid of
    Some remainderCid -> do
      Some remainder <- queryContractId alice remainderCid
      assertMsg "Remainder amount correct" (remainder.amount == 600.0)
    None -> fail "Expected remainder for partial burn"

  debug "Partial burn test passed!"
  pure ()
