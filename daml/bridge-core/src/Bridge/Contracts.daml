-- | Bridge Contracts for Issuer-Centric Canton-EVM Bridge
--
-- In the issuer-centric model:
-- - ISSUER (participant node) controls all operations
-- - End users do NOT manage Canton keys
-- - Issuer mints/burns on behalf of users
-- - No user "accept" step needed (issuer has authority)
--
-- Fingerprint resolution happens via FingerprintMapping in Common.FingerprintAuth

module Bridge.Contracts where

import Common.Types
import CIP56.Token
import Bridge.Events

-- =============================================================================
-- DEPOSIT FLOW: EVM → Canton (Issuer-Controlled)
-- =============================================================================
--
-- Flow:
-- 1. User deposits on EVM with their fingerprint
-- 2. Middleware creates PendingDeposit (see FingerprintAuth)
-- 3. Issuer resolves fingerprint → Party via FingerprintMapping
-- 4. Issuer creates DepositReceipt (see FingerprintAuth)
-- 5. Issuer mints tokens directly to user's Party (this module)

-- | Direct mint command for issuer
--
-- After resolving fingerprint to Party, issuer uses this to mint.
-- No user signature needed - issuer acts on behalf of users.
template MintCommand
  with
    issuer          : Party
    recipient       : Party         -- Resolved from FingerprintMapping
    tokenManagerCid : ContractId CIP56Manager
    amount          : Decimal
    evmTxHash       : Text          -- Source EVM transaction
    fingerprint     : Text          -- Original fingerprint (for audit)
    tokenSymbol     : Text          -- Token symbol for audit event
    auditObservers  : [Party]       -- Parties who can observe audit events
  where
    signatory issuer
    observer recipient, auditObservers
    
    -- | Execute the mint and create audit event
    choice ExecuteMint : (ContractId CIP56Holding, ContractId BridgeMintEvent)
      with
        timestamp : Time            -- Event timestamp
      controller issuer
      do
        assertMsg "amount > 0" (amount > 0.0)
        
        -- Mint the tokens
        holdingCid <- exercise tokenManagerCid Mint with
          to = recipient
          amount = amount
        
        -- Create audit event
        eventCid <- create BridgeMintEvent with
          issuer = issuer
          recipient = recipient
          amount = amount
          holdingCid = holdingCid
          tokenSymbol = tokenSymbol
          evmTxHash = evmTxHash
          fingerprint = fingerprint
          timestamp = timestamp
          auditObservers = auditObservers
        
        pure (holdingCid, eventCid)

-- =============================================================================
-- WITHDRAWAL FLOW: Canton → EVM (Issuer-Controlled)
-- =============================================================================
--
-- Flow:
-- 1. Issuer initiates withdrawal on behalf of user (off-chain request)
-- 2. Issuer locks user's tokens
-- 3. Issuer burns and creates WithdrawalEvent + BridgeBurnEvent
-- 4. Middleware processes WithdrawalEvent → releases on EVM

-- | Withdrawal request created by issuer on behalf of user
--
-- In issuer-centric model, user requests withdrawal off-chain.
-- Issuer creates this to process the withdrawal.
template WithdrawalRequest
  with
    issuer          : Party
    userParty       : Party         -- The Canton party (user doesn't sign)
    tokenManagerCid : ContractId CIP56Manager
    holdingCid      : ContractId CIP56Holding  -- User's tokens to withdraw
    amount          : Decimal
    evmDestination  : EvmAddress    -- Where to send on EVM
    fingerprint     : Text          -- User's fingerprint (for audit)
    tokenSymbol     : Text          -- Token symbol for audit event
    auditObservers  : [Party]       -- Parties who can observe audit events
  where
    signatory issuer
    observer userParty, auditObservers
    
    -- | Process the withdrawal and create audit events
    choice ProcessWithdrawal : (ContractId WithdrawalEvent, ContractId BridgeBurnEvent)
      with
        timestamp : Time            -- Event timestamp
      controller issuer
      do
        -- Verify holding
        holding <- fetch holdingCid
        assertMsg "Holding owner matches" (holding.owner == userParty)
        assertMsg "Withdrawal amount exceeds holding balance" (holding.amount >= amount)
        assertMsg "Amount must be positive" (amount > 0.0)
        
        -- Burn the tokens (partial burn returns remainder to user)
        remainderCid <- exercise tokenManagerCid Burn with holdingCid = holdingCid, amount = amount
        
        -- Create withdrawal event for middleware
        withdrawalCid <- create WithdrawalEvent with
          issuer = issuer
          userParty = userParty
          evmDestination = evmDestination
          amount = amount
          fingerprint = fingerprint
          tokenSymbol = tokenSymbol
          auditObservers = auditObservers
          status = Pending
        
        -- Create burn audit event
        burnEventCid <- create BridgeBurnEvent with
          issuer = issuer
          burnedFrom = userParty
          amount = amount
          remainderCid = remainderCid
          evmDestination = evmDestination
          tokenSymbol = tokenSymbol
          fingerprint = fingerprint
          timestamp = timestamp
          auditObservers = auditObservers
        
        pure (withdrawalCid, burnEventCid)

-- | Withdrawal event for middleware to process
template WithdrawalEvent
  with
    issuer          : Party
    userParty       : Party
    evmDestination  : EvmAddress
    amount          : Decimal
    fingerprint     : Text
    tokenSymbol     : Text          -- Token symbol for reference
    auditObservers  : [Party]       -- Parties who can observe this event
    status          : WithdrawalStatus
  where
    signatory issuer
    observer userParty, auditObservers
    
    -- | Mark as completed after EVM release
    choice CompleteWithdrawal : ContractId WithdrawalEvent
      with
        evmTxHash : Text
      controller issuer
      do
        create this with status = Completed evmTxHash
    
    -- | Mark as failed
    choice FailWithdrawal : ContractId WithdrawalEvent
      with
        reason : Text
      controller issuer
      do
        create this with status = Failed reason

-- | Withdrawal status
data WithdrawalStatus 
  = Pending
  | Completed Text   -- EVM tx hash
  | Failed Text      -- Reason
  deriving (Eq, Show)
