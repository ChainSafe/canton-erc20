module Bridge.Contracts where

import Common.Types
import CIP56.Token

-- =============================================================================
-- HASH-BASED MINT PROPOSAL (Resolves recipient from PartyHashRegistry)
-- =============================================================================
--
-- This template enables the middleware to pass the raw bytes32 cantonRecipient
-- from Ethereum's DepositToCanton event. Canton resolves it to a Party.
--
-- Flow:
-- 1. Ethereum: User calls depositToCanton(token, amount, bytes32 recipientHash)
-- 2. Middleware: Sees event, creates MintProposalByHash with the raw hash
-- 3. Canton: Resolves hash â†’ Party via PartyHashRegistry lookup
-- 4. Recipient: Accepts the proposal (same as standard flow)

-- | Mint proposal created by hash lookup
-- 
-- The operator creates this after looking up the PartyHashRegistry.
-- This is functionally equivalent to MintProposal but documents that
-- the recipient was resolved from a hash.
--
-- NOTE: Contract keys removed for DAML-LF 2.x compatibility.
-- Deduplication by reference should be handled at the application layer.
template MintProposalByHash
  with
    operator        : Party
    issuer          : Party
    recipient       : Party          -- Resolved from PartyHashRegistry
    recipientHash   : Text           -- Original hash from Ethereum (for audit)
    tokenManagerCid : ContractId CIP56Manager
    amount          : Decimal
    reference       : Text           -- EVM tx hash
    source          : ChainRef
  where
    signatory operator
    observer recipient

    -- | Recipient accepts, creating authorization for minting
    choice AcceptByHash : ContractId MintAuthorization
      controller recipient
      do
        create MintAuthorization with 
          operator, issuer, recipient, tokenManagerCid, amount, reference, source

-- =============================================================================
-- STANDARD MINT FLOW (Direct recipient specification)
-- =============================================================================

-- | Mint proposal for bridging tokens from EVM to Canton
--
-- NOTE: Contract keys removed for DAML-LF 2.x compatibility.
-- Deduplication by reference should be handled at the application layer.
template MintProposal
  with
    operator        : Party
    issuer          : Party
    recipient       : Party
    tokenManagerCid : ContractId CIP56Manager
    amount          : Decimal
    reference       : Text -- external transaction reference (e.g., EVM tx hash)
    source          : ChainRef
  where
    signatory operator
    observer recipient

    choice Accept : ContractId MintAuthorization
      controller recipient
      do
        -- Choice is consuming, so contract is automatically archived
        create MintAuthorization with operator, issuer, recipient, tokenManagerCid, amount, reference, source

-- Authorization for minting (after recipient accepts)
--
-- NOTE: Contract keys removed for DAML-LF 2.x compatibility.
template MintAuthorization
  with
    operator        : Party
    issuer          : Party
    recipient       : Party
    tokenManagerCid : ContractId CIP56Manager
    amount          : Decimal
    reference       : Text
    source          : ChainRef
  where
    signatory operator, recipient

    choice MintOnCanton : ContractId CIP56Holding
      controller operator
      do
        assertMsg "amount > 0" (amount > 0.0)
        -- Choice is consuming, so contract is automatically archived
        exercise tokenManagerCid Mint with
          to     = recipient
          amount = amount

-- Locked asset for redemption (Created by User, Locks the Holding)
--
-- NOTE: Contract keys removed for DAML-LF 2.x compatibility.
template RedeemRequest
  with
    owner           : Party
    operator        : Party
    issuer          : Party
    tokenManagerCid : ContractId CIP56Manager
    lockedAssetCid  : ContractId LockedAsset
    amount          : Decimal
    destination     : EvmAddress
    reference       : Text
  where
    signatory owner
    observer operator

    choice ApproveBurn : ContractId BurnEvent
      controller operator
      do
        lockedAsset <- fetch lockedAssetCid
        assertMsg "owner matches request" (lockedAsset.sender == owner)
        assertMsg "amount matches request" (lockedAsset.amount == amount)
        
        -- Burn the locked asset (CompleteTransfer -> Holding -> Burn? No, that unlocks it first)
        -- We need a way to BURN a LockedAsset directly or unlock-and-burn atomically.
        -- Since LockedAsset is in CIP56.Token, we can't modify it easily here without circular deps?
        -- Wait, CIP56.Token imports nothing from Bridge.Contracts.
        -- LockedAsset has `Unlock` (refund) and `CompleteTransfer` (deliver).
        -- We need a `Burn` choice on LockedAsset? Or unlock it to Operator then Operator burns it?
        
        -- Pattern:
        -- 1. User Locks asset for Operator.
        -- 2. User creates RedeemRequest pointing to LockedAsset.
        -- 3. Operator exercises `CompleteTransfer` on LockedAsset (claiming it).
        -- 4. Operator exercises `Burn` on the resulting Holding.
        
        holdingCid <- exercise lockedAssetCid CompleteTransfer with complianceProofCid = None
        exercise tokenManagerCid Burn with holdingCid = holdingCid
        
        -- Choice is consuming, so contract is automatically archived
        create BurnEvent with operator, owner, destination, amount, reference, direction = ToEvm

-- Event emitted after burn (for middleware to process on EVM side)
template BurnEvent
  with
    operator    : Party
    owner       : Party
    destination : EvmAddress
    amount      : Decimal
    reference   : Text
    direction   : BridgeDirection
  where
    signatory operator
    observer owner
