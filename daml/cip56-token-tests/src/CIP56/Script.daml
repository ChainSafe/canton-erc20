module CIP56.Script where

import Daml.Script
import Common.Types
import CIP56.Token
import CIP56.Compliance

-- Simple party allocation for tests (SDK 3.x compatible)
allocateTestParty : Text -> Script Party
allocateTestParty name = allocatePartyByHint (PartyIdHint name)

test : Script ()
test = script do
  issuer <- allocateTestParty "issuer"
  alice  <- allocateTestParty "alice"
  bob    <- allocateTestParty "bob"

  let meta = ExtendedMetadata with 
        name = "Canton Coin"
        symbol = "CCN"
        decimals = 6
        isin = None
        dtiCode = None
        regulatoryInfo = None

  -- Setup Compliance
  rulesCid <- submit issuer do
    createCmd ComplianceRules with
      issuer = issuer
      isWhitelistEnabled = True
      observers = [alice, bob]

  -- Issue proofs to Alice and Bob
  aliceProofCid <- submit issuer do
    createCmd ComplianceProof with issuer, user = alice

  bobProofCid <- submit issuer do
    createCmd ComplianceProof with issuer, user = bob

  tmCid <- submit issuer do
    createCmd CIP56Manager with issuer, meta

  aHolding <- submit issuer do
    exerciseCmd tmCid Mint with to = alice, amount = 100.0

  -- Locked Asset Flow (Safe Transfer)
  
  -- 1. Alice locks funds for Bob
  (lockedCid, changeCid) <- submit alice do
    exerciseCmd aHolding Lock with
      receiver = bob
      value = 30.0
      complianceRulesCid = Some rulesCid
  
  -- 2. Bob claims the locked funds using his proof
  _ <- submit bob do
    exerciseCmd lockedCid CompleteTransfer with
      complianceProofCid = Some bobProofCid

  pure ()

-- | Test Transfer with existingRecipientHolding (fragmentation prevention)
testTransferWithMerge : Script ()
testTransferWithMerge = script do
  issuer <- allocateTestParty "issuer"
  alice  <- allocateTestParty "alice"
  bob    <- allocateTestParty "bob"

  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None

  tmCid <- submit issuer do
    createCmd CIP56Manager with issuer, meta

  -- Mint to Alice and Bob
  aliceHolding <- submit issuer do
    exerciseCmd tmCid Mint with to = alice, amount = 500.0

  bobHolding <- submit issuer do
    exerciseCmd tmCid Mint with to = bob, amount = 200.0

  -- Alice transfers 100 to Bob, merging into Bob's existing holding.
  -- Uses submitMulti with readAs issuer so alice can fetch bob's holding
  -- (in production, the middleware submits with readAs: [issuerParty])
  (bobNewHolding, aliceChange) <- submitMulti [alice] [issuer] do
    exerciseCmd aliceHolding Transfer with
      to = bob
      value = 100.0
      existingRecipientHolding = Some bobHolding
      complianceRulesCid = None
      complianceProofCid = None

  -- Verify Bob has merged amount (200 + 100 = 300)
  Some bh <- queryContractId bob bobNewHolding
  assertMsg "Bob should have 300 (merged)" (bh.amount == 300.0)

  -- Verify Alice has change (500 - 100 = 400)
  case aliceChange of
    Some changeCid -> do
      Some ah <- queryContractId alice changeCid
      assertMsg "Alice should have 400" (ah.amount == 400.0)
    None -> fail "Expected Alice to have change"

  pure ()

-- | Test Transfer without existing recipient (first-time recipient)
testTransferNoExisting : Script ()
testTransferNoExisting = script do
  issuer <- allocateTestParty "issuer"
  alice  <- allocateTestParty "alice"
  bob    <- allocateTestParty "bob"

  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None

  tmCid <- submit issuer do
    createCmd CIP56Manager with issuer, meta

  aliceHolding <- submit issuer do
    exerciseCmd tmCid Mint with to = alice, amount = 500.0

  -- Transfer to Bob with no existing holding (None)
  (bobHolding, aliceChange) <- submit alice do
    exerciseCmd aliceHolding Transfer with
      to = bob
      value = 200.0
      existingRecipientHolding = None
      complianceRulesCid = None
      complianceProofCid = None

  -- Verify Bob received exactly the transferred amount
  Some bh <- queryContractId bob bobHolding
  assertMsg "Bob should have 200" (bh.amount == 200.0)

  -- Verify Alice change
  case aliceChange of
    Some changeCid -> do
      Some ah <- queryContractId alice changeCid
      assertMsg "Alice should have 300" (ah.amount == 300.0)
    None -> fail "Expected Alice to have change"

  pure ()
