module Native.TokenTest where

import Daml.Script
import DA.Time (time)
import DA.Date (date, Month(..))

import CIP56.Token
import Common.Types
import Native.Token
import Native.Events

-- | Test basic mint functionality
testIssuerMint : Script ()
testIssuerMint = do
  -- Setup parties
  issuer <- allocateParty "Issuer"
  recipient <- allocateParty "Recipient"
  auditor <- allocateParty "Auditor"
  
  -- Create token metadata
  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None
  
  -- Create CIP56Manager
  managerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = meta
  
  -- Create NativeTokenConfig
  configCid <- submit issuer do
    createCmd NativeTokenConfig with
      issuer = issuer
      tokenManagerCid = managerCid
      meta = meta
      auditObservers = [auditor]
  
  -- Mint tokens with user fingerprint
  let eventTime = time (date 2024 Jan 15) 12 0 0
  let testFingerprint = "0xabc123def456"
  (holdingCid, mintEventCid) <- submit issuer do
    exerciseCmd configCid IssuerMint with
      recipient = recipient
      amount = 1000.0
      eventTime = eventTime
      userFingerprint = testFingerprint
  
  -- Verify holding was created
  holding <- queryContractId recipient holdingCid
  case holding of
    None -> fail "Holding not found"
    Some h -> do
      assertMsg "Holding amount should be 1000" (h.amount == 1000.0)
      assertMsg "Holding owner should be recipient" (h.owner == recipient)
  
  -- Verify mint event was created with fingerprint
  mintEvent <- queryContractId issuer mintEventCid
  case mintEvent of
    None -> fail "MintEvent not found"
    Some e -> do
      assertMsg "Event amount should be 1000" (e.amount == 1000.0)
      assertMsg "Event recipient should match" (e.recipient == recipient)
      assertMsg "Event symbol should match" (e.tokenSymbol == "TEST")
      assertMsg "Event fingerprint should match" (e.userFingerprint == testFingerprint)
  
  pure ()

-- | Test burn functionality
testIssuerBurn : Script ()
testIssuerBurn = do
  -- Setup parties
  issuer <- allocateParty "Issuer"
  holder <- allocateParty "Holder"
  auditor <- allocateParty "Auditor"
  
  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None
  
  -- Create CIP56Manager and NativeTokenConfig
  managerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = meta
  
  configCid <- submit issuer do
    createCmd NativeTokenConfig with
      issuer = issuer
      tokenManagerCid = managerCid
      meta = meta
      auditObservers = [auditor]
  
  -- Mint tokens first
  let mintTime = time (date 2024 Jan 15) 12 0 0
  let holderFingerprint = "0xholder789"
  (holdingCid, _) <- submit issuer do
    exerciseCmd configCid IssuerMint with
      recipient = holder
      amount = 1000.0
      eventTime = mintTime
      userFingerprint = holderFingerprint
  
  -- Burn partial amount
  let burnTime = time (date 2024 Jan 15) 13 0 0
  (remainderCid, burnEventCid) <- submit issuer do
    exerciseCmd configCid IssuerBurn with
      holdingCid = holdingCid
      amount = 400.0
      eventTime = burnTime
      userFingerprint = holderFingerprint
  
  -- Verify remainder holding
  case remainderCid of
    None -> fail "Remainder holding should exist"
    Some cid -> do
      holding <- queryContractId holder cid
      case holding of
        None -> fail "Remainder holding not found"
        Some h -> assertMsg "Remainder should be 600" (h.amount == 600.0)
  
  -- Verify burn event with fingerprint
  burnEvent <- queryContractId issuer burnEventCid
  case burnEvent of
    None -> fail "BurnEvent not found"
    Some e -> do
      assertMsg "Burn amount should be 400" (e.amount == 400.0)
      assertMsg "Burned from should be holder" (e.burnedFrom == holder)
      assertMsg "Burn fingerprint should match" (e.userFingerprint == holderFingerprint)
  
  pure ()

-- | Test full mint to exact amount burn scenario
testFullBurn : Script ()
testFullBurn = do
  issuer <- allocateParty "Issuer"
  holder <- allocateParty "Holder"
  
  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None
  
  managerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = meta
  
  configCid <- submit issuer do
    createCmd NativeTokenConfig with
      issuer = issuer
      tokenManagerCid = managerCid
      meta = meta
      auditObservers = []
  
  let mintTime = time (date 2024 Jan 15) 12 0 0
  let holderFp = "0xfullburn333"
  (holdingCid, _) <- submit issuer do
    exerciseCmd configCid IssuerMint with
      recipient = holder
      amount = 500.0
      eventTime = mintTime
      userFingerprint = holderFp
  
  -- Burn exact amount
  let burnTime = time (date 2024 Jan 15) 13 0 0
  (remainderCid, _) <- submit issuer do
    exerciseCmd configCid IssuerBurn with
      holdingCid = holdingCid
      amount = 500.0
      eventTime = burnTime
      userFingerprint = holderFp
  
  -- Verify no remainder (full burn)
  case remainderCid of
    None -> pure ()  -- Expected: no remainder for full burn
    Some _ -> fail "Full burn should not have remainder"
  
  pure ()

-- | Test adding and removing audit observers
testAuditObservers : Script ()
testAuditObservers = do
  issuer <- allocateParty "Issuer"
  auditor1 <- allocateParty "Auditor1"
  auditor2 <- allocateParty "Auditor2"
  
  let meta = ExtendedMetadata with
        name = "Test Token"
        symbol = "TEST"
        decimals = 18
        isin = None
        dtiCode = None
        regulatoryInfo = None
  
  managerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = meta
  
  configCid <- submit issuer do
    createCmd NativeTokenConfig with
      issuer = issuer
      tokenManagerCid = managerCid
      meta = meta
      auditObservers = [auditor1]
  
  -- Add another auditor
  configCid2 <- submit issuer do
    exerciseCmd configCid AddAuditObserver with
      newObserver = auditor2
  
  -- Remove first auditor
  configCid3 <- submit issuer do
    exerciseCmd configCid2 RemoveAuditObserver with
      observerToRemove = auditor1
  
  -- Verify final state
  config <- queryContractId issuer configCid3
  case config of
    None -> fail "Config not found"
    Some c -> do
      assertMsg "Should have auditor2" (auditor2 `elem` c.auditObservers)
      assertMsg "Should not have auditor1" (not (auditor1 `elem` c.auditObservers))
  
  pure ()
