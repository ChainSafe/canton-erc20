module CIP56.Token where

import Common.Types
import CIP56.Compliance

-- Forward declaration to break cycle (Lock choice needs LockedAsset)
-- But circular imports are tricky. 
-- Better approach: Move LockedAsset to separate module and avoid circular dependency
-- OR define LockedAsset here if small.
-- LockedAsset needs `CIP56Holding` to unlock.
-- CIP56Holding needs `LockedAsset` to lock.
-- This is a cycle.
-- Standard Daml solution: Put them in same module or use a "Factory" pattern.
-- Let's put LockedAsset in this module for simplicity of Phase 1.

-- Locked asset representing funds in transit (Moved from Transfer.daml to avoid cycle)
template LockedAsset
  with
    issuer : Party
    sender : Party
    receiver : Party
    amount : Decimal
    meta : ExtendedMetadata
    complianceRulesCid : Optional (ContractId ComplianceRules)
  where
    signatory issuer, sender
    observer receiver

    choice CompleteTransfer : ContractId CIP56Holding
      with
        complianceProofCid : Optional (ContractId ComplianceProof)
      controller receiver
      do
        -- Check compliance
        case complianceRulesCid of
          Some rulesCid -> do
            rules <- fetch rulesCid
            assertMsg "Compliance rules issuer mismatch" (rules.issuer == issuer)
            if rules.isWhitelistEnabled then do
               case complianceProofCid of
                 Some proofCid -> do
                   valid <- exercise rulesCid ValidateProof with proofCid = proofCid, user = receiver
                   assertMsg "Invalid compliance proof" valid
                 None -> abort "Compliance proof required"
            else pure ()
          None -> pure ()

        -- Create final holding for receiver
        create CIP56Holding with
          issuer = issuer
          owner = receiver
          amount = amount
          meta = meta

    choice Unlock : ContractId CIP56Holding
      controller sender
      do
        -- Refund to sender
        create CIP56Holding with
          issuer = issuer
          owner = sender
          amount = amount
          meta = meta

-- CIP-56 compliant token implementation

template CIP56Manager
  with
    issuer : Party
    meta   : ExtendedMetadata
  where
    signatory issuer

    -- NOTE: Contract key removed for DAML-LF 2.x compatibility
    -- Track CIP56Manager ContractId in your application instead of using fetchByKey

    -- Mint tokens to a recipient (nonconsuming so manager can be reused)
    nonconsuming choice Mint : ContractId CIP56Holding
      with
        to     : Party
        amount : Decimal
      controller issuer
      do
        assertMsg "amount > 0" (amount > 0.0)
        create CIP56Holding with issuer, owner = to, amount, meta

    -- Burn tokens (nonconsuming so manager can be reused)
    nonconsuming choice Burn : ()
      with
        holdingCid : ContractId CIP56Holding
      controller issuer
      do
        holding <- fetch holdingCid
        assertMsg "issuer matches" (holding.issuer == issuer)
        archive holdingCid

    -- Update token metadata
    choice UpdateMetadata : ContractId CIP56Manager
      with
        newMeta : ExtendedMetadata
      controller issuer
      do
        create this with meta = newMeta

-- CIP-56 compliant holding template
template CIP56Holding
  with
    issuer : Party
    owner  : Party
    amount : Decimal
    meta   : ExtendedMetadata
  where
    signatory issuer
    observer  owner

    -- Direct Transfer (Atomic)
    choice Transfer : (ContractId CIP56Holding, Optional (ContractId CIP56Holding))
      with
        to    : Party
        value : Decimal
        complianceRulesCid : Optional (ContractId ComplianceRules)
        complianceProofCid : Optional (ContractId ComplianceProof)
      controller owner
      do
        assertMsg "value > 0" (value > 0.0)
        assertMsg "sufficient balance" (amount >= value)

        -- Check compliance if rules provided
        case complianceRulesCid of
          Some rulesCid -> do
            rules <- fetch rulesCid
            assertMsg "Compliance rules issuer mismatch" (rules.issuer == issuer)
            
            if rules.isWhitelistEnabled then do
              case complianceProofCid of
                Some proofCid -> do
                  -- Validate receiver's proof
                  valid <- exercise rulesCid ValidateProof with proofCid = proofCid, user = to
                  assertMsg "Invalid compliance proof" valid
                None -> abort "Compliance proof required but not provided"
            else pure ()
            
          None -> pure ()

        recipientCid <- create CIP56Holding with
          issuer = issuer
          owner  = to
          amount = value
          meta   = meta

        changeCid <- if amount > value
          then do
            cid <- create CIP56Holding with
              issuer = issuer
              owner  = owner
              amount = amount - value
              meta   = meta
            pure (Some cid)
          else pure None

        pure (recipientCid, changeCid)

    -- Lock funds for async transfer (Safe Transfer / Transfer Proposal)
    choice Lock : (ContractId LockedAsset, Optional (ContractId CIP56Holding))
      with
        receiver : Party
        value : Decimal
        complianceRulesCid : Optional (ContractId ComplianceRules)
      controller owner
      do
        assertMsg "value > 0" (value > 0.0)
        assertMsg "sufficient balance" (amount >= value)
        
        lockedCid <- create LockedAsset with
          issuer = issuer
          sender = owner
          receiver = receiver
          amount = value
          meta = meta
          complianceRulesCid = complianceRulesCid
          
        changeCid <- if amount > value
          then do
            cid <- create CIP56Holding with
              issuer = issuer
              owner  = owner
              amount = amount - value
              meta   = meta
            pure (Some cid)
          else pure None
          
        pure (lockedCid, changeCid)
