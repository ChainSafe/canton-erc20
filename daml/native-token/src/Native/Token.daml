module Native.Token where

import CIP56.Token
import Common.Types (ExtendedMetadata)
import Native.Events

template NativeTokenConfig
  with
    issuer : Party
    tokenManagerCid : ContractId CIP56Manager
    meta : ExtendedMetadata
    auditObservers : [Party]
  where
    signatory issuer
    observer auditObservers

    nonconsuming choice IssuerMint : (ContractId CIP56Holding, ContractId MintEvent)
      with
        recipient : Party
        amount : Decimal
        eventTime : Time
        userFingerprint : Text  -- EVM-derived fingerprint of the user this mint is for
      controller issuer
      do
        assertMsg "amount must be positive" (amount > 0.0)
        
        holdingCid <- exercise tokenManagerCid Mint with
          to = recipient
          amount = amount
        
        eventCid <- create MintEvent with
          issuer, recipient, amount, holdingCid
          tokenSymbol = meta.symbol
          timestamp = eventTime
          auditObservers = auditObservers
          userFingerprint = userFingerprint
        
        pure (holdingCid, eventCid)

    nonconsuming choice IssuerBurn : (Optional (ContractId CIP56Holding), ContractId BurnEvent)
      with
        holdingCid : ContractId CIP56Holding
        amount : Decimal
        eventTime : Time
        userFingerprint : Text  -- EVM-derived fingerprint of the user this burn is for
      controller issuer
      do
        assertMsg "amount must be positive" (amount > 0.0)
        holding <- fetch holdingCid
        
        remainderCid <- exercise tokenManagerCid Burn with holdingCid, amount
        
        eventCid <- create BurnEvent with
          issuer
          burnedFrom = holding.owner
          amount, remainderCid
          tokenSymbol = meta.symbol
          timestamp = eventTime
          auditObservers = auditObservers
          userFingerprint = userFingerprint
        
        pure (remainderCid, eventCid)

    nonconsuming choice IssuerTransfer : (Optional (ContractId CIP56Holding), ContractId CIP56Holding, ContractId TransferEvent)
      with
        senderHoldingCid : ContractId CIP56Holding
        recipient : Party
        amount : Decimal
        eventTime : Time
        senderFingerprint : Text     -- Sender's EVM-derived fingerprint
        recipientFingerprint : Text  -- Recipient's EVM-derived fingerprint
      controller issuer
      do
        assertMsg "amount must be positive" (amount > 0.0)
        senderHolding <- fetch senderHoldingCid
        let sender = senderHolding.owner
        assertMsg "sender has sufficient balance" (senderHolding.amount >= amount)
        
        senderRemainderCid <- exercise tokenManagerCid Burn with
          holdingCid = senderHoldingCid, amount
        
        recipientHoldingCid <- exercise tokenManagerCid Mint with
          to = recipient, amount
        
        eventCid <- create TransferEvent with
          issuer, sender, recipient, amount
          senderRemainderCid, recipientHoldingCid
          tokenSymbol = meta.symbol
          timestamp = eventTime
          auditObservers = auditObservers
          senderFingerprint = senderFingerprint
          recipientFingerprint = recipientFingerprint
        
        pure (senderRemainderCid, recipientHoldingCid, eventCid)

    nonconsuming choice GetMetadata : ExtendedMetadata
      controller issuer
      do pure meta

    choice SetMetadata : ContractId NativeTokenConfig
      with
        newMeta : ExtendedMetadata
      controller issuer
      do create this with meta = newMeta

    choice AddAuditObserver : ContractId NativeTokenConfig
      with
        newObserver : Party
      controller issuer
      do create this with auditObservers = newObserver :: auditObservers

    choice RemoveAuditObserver : ContractId NativeTokenConfig
      with
        observerToRemove : Party
      controller issuer
      do create this with auditObservers = filter (/= observerToRemove) auditObservers
