module Wayfinder.Script where

import Daml.Script
import Common.Types
import CIP56.Token
import Bridge.Contracts
import Wayfinder.Bridge

ensureParty : Text -> PartyIdHint -> Script Party
ensureParty displayName hint = do
  known <- listKnownParties
  case [ p.party | p <- known, p.displayName == Some displayName ] of
    p :: _ -> pure p
    []     -> allocatePartyWithHint displayName hint

testFullCycle : Script ()
testFullCycle = script do
  -- 1. Setup Parties
  operator <- ensureParty "WayfinderOperator" (PartyIdHint "operator")
  alice <- ensureParty "Alice" (PartyIdHint "alice")
  
  -- 2. Deploy Token Manager for PRIME
  tokenManagerCid <- submit operator do
    createCmd CIP56Manager with
      issuer = operator
      meta = primeMetadata

  -- 3. Deploy Bridge Config
  configCid <- submit operator do
    createCmd WayfinderBridgeConfig with
      operator = operator
      tokenManagerCid = tokenManagerCid

  -- 4. DEPOSIT FLOW (Ethereum -> Canton)
  -- Simulate operator detecting a lock event on Ethereum
  let ethTxHash = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  let depositAmount = 100.0

  -- Operator creates proposal
  proposalCid <- submit operator do
    exerciseCmd configCid CreateMintProposal with
      recipient = alice
      amount = depositAmount
      txHash = ethTxHash

  -- Alice accepts proposal (authorizes mint)
  authCid <- submit alice do
    exerciseCmd proposalCid Accept

  -- Operator executes mint
  holdingCid <- submit operator do
    exerciseCmd authCid MintOnCanton

  -- Verify Alice has funds
  Some holding <- queryContractId alice holdingCid
  assertMsg "Alice received PRIME" (holding.amount == depositAmount)
  assertMsg "Correct Symbol" (holding.meta.symbol == "PRIME")

  -- 5. WITHDRAWAL FLOW (Canton -> Ethereum)
  -- Alice requests redemption to her EVM address
  let evmDest = EvmAddress "0xAliceEthAddress..."
  let redeemRef = "req-001"
  
  -- NEW FLOW: Lock -> RedeemRequest -> Burn
  
  -- 1. Alice locks funds for Operator
  (lockedCid, _) <- submit alice do
    exerciseCmd holdingCid Lock with
      receiver = operator
      value = depositAmount
      complianceRulesCid = None

  -- 2. Alice creates RedeemRequest pointing to LockedAsset
  redeemRequestCid <- submit alice do
    createCmd RedeemRequest with
      owner = alice
      operator = operator
      issuer = operator
      tokenManagerCid = tokenManagerCid
      lockedAssetCid = lockedCid
      amount = depositAmount
      destination = evmDest
      reference = redeemRef

  -- 3. Operator approves burn (claims locked asset, then burns it)
  burnEventCid <- submit operator do
    exerciseCmd redeemRequestCid ApproveBurn

  -- Verify Burn Event exists (Middleware would listen for this)
  Some burnEvent <- queryContractId operator burnEventCid
  assertMsg "Burn destination correct" (burnEvent.destination == evmDest)
  assertMsg "Burn amount correct" (burnEvent.amount == depositAmount)
  
  pure ()
