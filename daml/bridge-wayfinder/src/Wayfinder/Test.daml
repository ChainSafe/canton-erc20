module Wayfinder.Test where

import Daml.Script
import Common.Types
import CIP56.Token
import Bridge.Contracts
import Wayfinder.Bridge

-- | Helper to allocate parties with readable names
setupParties : Script (Party, Party, Party)
setupParties = do
  operator <- allocatePartyByHint (PartyIdHint "operator")
  alice <- allocatePartyByHint (PartyIdHint "alice")
  bob <- allocatePartyByHint (PartyIdHint "bob")
  return (operator, alice, bob)

-- | Full end-to-end test cycle for Wayfinder PROMPT Bridge
--
-- This script tests the entire lifecycle of bridging PROMPT tokens:
-- 1. Initialization: Operator sets up the Token Manager and Bridge Config.
-- 2. Deposit (EVM -> Canton):
--    - Operator proposes a mint (representing a lock on Ethereum).
--    - User (Alice) accepts the proposal.
--    - Wrapped PROMPT tokens are minted on Canton.
-- 3. Transfer (Canton):
--    - Alice transfers some PROMPT to Bob to verify token mechanics.
-- 4. Withdrawal (Canton -> EVM):
--    - Bob requests redemption (bridging back to Ethereum).
--    - This involves Locking the asset -> Creating RedeemRequest -> Operator Burning.
-- 5. Verification:
--    - Confirm BurnEvent is emitted with correct details for the relayer.
testWayfinderBridge : Script ()
testWayfinderBridge = script do
  -- ===========================================================================
  -- 1. INITIALIZATION
  -- ===========================================================================
  (operator, alice, bob) <- setupParties
  
  debug ">>> 1. Initialization: Deploying contracts..."

  -- Operator deploys the Token Manager for the wrapped PROMPT token
  tokenManagerCid <- submit operator do
    createCmd CIP56Manager with
      issuer = operator
      meta = promptMetadata

  -- Operator deploys the Bridge Configuration
  configCid <- submit operator do
    createCmd WayfinderBridgeConfig with
      operator = operator
      tokenManagerCid = tokenManagerCid

  debug "    [OK] Token Manager and Bridge Config deployed."

  -- ===========================================================================
  -- 2. DEPOSIT FLOW (Ethereum -> Canton)
  -- ===========================================================================
  debug ">>> 2. Deposit Flow: Bridging 100.0 PROMPT from Ethereum to Alice..."

  -- Simulate: Operator detects a Deposit event on Ethereum (tx hash: 0x123...)
  let ethTxHash = "0x1234567890abcdef..."
  let depositAmount = 100.0

  -- Step 2a: Operator creates a Mint Proposal on Canton
  proposalCid <- submit operator do
    exerciseCmd configCid CreateMintProposal with
      recipient = alice
      amount = depositAmount
      txHash = ethTxHash

  -- Step 2b: Alice accepts the proposal (Compliance / Authorization check)
  -- This creates a MintAuthorization contract
  authCid <- submit alice do
    exerciseCmd proposalCid Accept

  -- Step 2c: Operator executes the minting
  aliceHoldingCid <- submit operator do
    exerciseCmd authCid MintOnCanton

  -- Verify Alice's balance
  Some aliceHolding <- queryContractId alice aliceHoldingCid
  assertMsg "Alice should have 100.0 PROMPT" (aliceHolding.amount == 100.0)
  assertMsg "Token symbol should be PROMPT" (aliceHolding.meta.symbol == "PROMPT")
  
  debug "    [OK] Deposit complete. Alice holds 100.0 PROMPT."

  -- ===========================================================================
  -- 3. TRANSFER (Canton Native)
  -- ===========================================================================
  debug ">>> 3. Native Transfer: Alice transfers 40.0 PROMPT to Bob..."

  -- Alice transfers 40.0 to Bob
  (bobHoldingCid, maybeAliceChangeCid) <- submit alice do
    exerciseCmd aliceHoldingCid Transfer with
      to = bob
      value = 40.0
      complianceRulesCid = None -- No extra compliance rules for this test
      complianceProofCid = None

  -- Verify Bob's balance
  Some bobHolding <- queryContractId bob bobHoldingCid
  assertMsg "Bob should have 40.0 PROMPT" (bobHolding.amount == 40.0)

  -- Verify Alice's change
  case maybeAliceChangeCid of
    Some changeCid -> do
      Some change <- queryContractId alice changeCid
      assertMsg "Alice should have 60.0 PROMPT remaining" (change.amount == 60.0)
    None -> fail "Alice should have received change"

  debug "    [OK] Transfer successful."

  -- ===========================================================================
  -- 4. WITHDRAWAL FLOW (Canton -> Ethereum)
  -- ===========================================================================
  debug ">>> 4. Withdrawal Flow: Bob bridges 40.0 PROMPT back to Ethereum..."

  let evmDestination = EvmAddress "0xBobEthAddress..."
  let redemptionRef = "req-bridge-back-001"

  -- Step 4a: Bob locks his funds for the Operator
  -- This moves funds from CIP56Holding to LockedAsset
  (lockedAssetCid, _) <- submit bob do
    exerciseCmd bobHoldingCid Lock with
      receiver = operator
      value = 40.0
      complianceRulesCid = None

  -- Step 4b: Bob creates a Redeem Request pointing to the locked asset
  redeemRequestCid <- submit bob do
    createCmd RedeemRequest with
      owner = bob
      operator = operator
      issuer = operator
      tokenManagerCid = tokenManagerCid
      lockedAssetCid = lockedAssetCid
      amount = 40.0
      destination = evmDestination
      reference = redemptionRef

  -- Step 4c: Operator processes the redemption (Approved Burn)
  -- This claims the LockedAsset (CompleteTransfer) and immediately Burns it
  burnEventCid <- submit operator do
    exerciseCmd redeemRequestCid ApproveBurn

  debug "    [OK] Redemption processed on Canton."

  -- ===========================================================================
  -- 5. VERIFICATION
  -- ===========================================================================
  debug ">>> 5. Final Verification..."

  -- Verify the BurnEvent was emitted with correct details
  -- The Middleware will listen for this event to unlock/mint on Ethereum
  Some burnEvent <- queryContractId operator burnEventCid
  
  assertMsg "Burn amount matches request" (burnEvent.amount == 40.0)
  assertMsg "Burn destination matches request" (burnEvent.destination == evmDestination)
  assertMsg "Burn operator is correct" (burnEvent.operator == operator)
  assertMsg "Burn owner is correct" (burnEvent.owner == bob)

  debug "    [OK] BurnEvent confirmed correct."
  debug ">>> Test Cycle Complete Successfully!"
  
  pure ()

-- =============================================================================
-- HASH-BASED REGISTRATION AND MINT FLOW TEST
-- =============================================================================

-- | Test the hash-based recipient resolution flow
--
-- This demonstrates the production flow where:
-- 1. User registers their Canton party hash on Canton (one-time)
-- 2. User deposits on Ethereum with their hash as cantonRecipient
-- 3. Middleware looks up the PartyHashRegistry ContractId for that hash
-- 4. Middleware calls CreateMintProposalByHash with the registry ContractId
--
-- NOTE: In SDK 3.x (DAML-LF 2.x), contract keys are not supported.
-- The middleware must track PartyHashRegistry ContractIds for each hash.
testHashBasedMintFlow : Script ()
testHashBasedMintFlow = script do
  -- ===========================================================================
  -- 1. INITIALIZATION
  -- ===========================================================================
  (operator, alice, bob) <- setupParties
  
  debug ">>> Hash-Based Flow Test"
  debug ">>> 1. Initialization..."

  tokenManagerCid <- submit operator do
    createCmd CIP56Manager with
      issuer = operator
      meta = promptMetadata

  configCid <- submit operator do
    createCmd WayfinderBridgeConfig with
      operator = operator
      tokenManagerCid = tokenManagerCid

  debug "    [OK] Bridge deployed."

  -- ===========================================================================
  -- 2. USER REGISTRATION (One-time on Canton)
  -- ===========================================================================
  debug ">>> 2. Alice registers her party hash..."

  -- Alice computes her hash off-chain: keccak256("Alice::1220...")
  -- For this test, we use a simulated hash
  let alicePartyHash = "0xabcd1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab"
  let aliceEvmAddress = EvmAddress "0xAliceEthWallet..."

  -- Alice submits a registration request
  registrationRequestCid <- submit alice do
    createCmd PartyHashRegistrationRequest with
      owner = alice
      operator = operator
      partyHash = alicePartyHash
      evmAddress = Some aliceEvmAddress

  debug "    [OK] Alice submitted registration request."

  -- Operator approves the registration
  aliceRegistryCid <- submit operator do
    exerciseCmd configCid ApprovePartyRegistration with
      requestCid = registrationRequestCid

  -- Verify registration
  Some aliceRegistry <- queryContractId alice aliceRegistryCid
  assertMsg "Registry owner should be Alice" (aliceRegistry.owner == alice)
  assertMsg "Registry hash should match" (aliceRegistry.partyHash == alicePartyHash)

  debug "    [OK] Registration approved. Alice can now receive deposits."

  -- ===========================================================================
  -- 3. HASH-BASED DEPOSIT (Middleware passes registry ContractId)
  -- ===========================================================================
  debug ">>> 3. Deposit with registry-based recipient resolution..."

  -- Simulate: Middleware sees DepositToCanton event on Ethereum
  -- Event contains: token, sender (0xAliceEthWallet), cantonRecipient (bytes32), amount, nonce
  -- 
  -- IMPORTANT: In SDK 3.x, the middleware must:
  -- 1. Maintain a mapping of partyHash -> PartyHashRegistry ContractId
  -- 2. Look up the ContractId for the incoming hash
  -- 3. Pass that ContractId to CreateMintProposalByHash
  let ethTxHash = "0xEthDepositTx123..."
  let depositAmount = 250.0

  -- Middleware calls CreateMintProposalByHash with registry ContractId
  proposalCid <- submit operator do
    exerciseCmd configCid CreateMintProposalByHash with
      registryCid = aliceRegistryCid  -- Middleware looked this up
      amount = depositAmount
      txHash = ethTxHash

  debug "    [OK] Mint proposal created via registry lookup."

  -- Verify the proposal resolved to Alice
  Some proposal <- queryContractId alice proposalCid
  assertMsg "Recipient should be Alice" (proposal.recipient == alice)
  assertMsg "Hash should be preserved for audit" (proposal.recipientHash == alicePartyHash)

  -- ===========================================================================
  -- 4. ALICE ACCEPTS (Same as standard flow from here)
  -- ===========================================================================
  debug ">>> 4. Alice accepts the proposal..."

  authCid <- submit alice do
    exerciseCmd proposalCid AcceptByHash

  aliceHoldingCid <- submit operator do
    exerciseCmd authCid MintOnCanton

  -- Verify Alice's balance
  Some aliceHolding <- queryContractId alice aliceHoldingCid
  assertMsg "Alice should have 250.0 PROMPT" (aliceHolding.amount == 250.0)

  debug "    [OK] Alice received 250.0 PROMPT via registry-based flow."

  -- ===========================================================================
  -- 5. BOB REGISTERS AND RECEIVES
  -- ===========================================================================
  debug ">>> 5. Bob registers and receives deposit..."

  let bobPartyHash = "0xBBBB1234567890abcdef1234567890abcdef1234567890abcdef1234567890BB"

  -- Bob registers directly (operator can allow direct registration)
  bobRegistryCid <- submitMulti [bob, operator] [] do
    createCmd PartyHashRegistry with
      owner = bob
      operator = operator
      partyHash = bobPartyHash
      evmAddress = Some (EvmAddress "0xBobEthWallet...")

  -- Bob receives deposit via registry ContractId
  bobProposalCid <- submit operator do
    exerciseCmd configCid CreateMintProposalByHash with
      registryCid = bobRegistryCid
      amount = 100.0
      txHash = "0xBobDepositTx..."

  bobAuthCid <- submit bob do
    exerciseCmd bobProposalCid AcceptByHash

  bobHoldingCid <- submit operator do
    exerciseCmd bobAuthCid MintOnCanton

  Some bobHolding <- queryContractId bob bobHoldingCid
  assertMsg "Bob should have 100.0 PROMPT" (bobHolding.amount == 100.0)

  debug "    [OK] Bob received 100.0 PROMPT."

  debug ">>> Hash-Based Flow Test Complete!"
  pure ()
