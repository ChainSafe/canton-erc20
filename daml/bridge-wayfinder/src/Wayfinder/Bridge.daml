-- | Wayfinder Bridge - Issuer-Centric Implementation
--
-- This module implements the Wayfinder PROMPT token bridge using
-- the issuer-centric model where:
-- - ISSUER controls all party allocations
-- - ISSUER knows all fingerprints (from AllocateParty responses)
-- - ISSUER mints/burns on behalf of users
-- - End users do NOT manage Canton keys

module Wayfinder.Bridge where

import Common.Types
import Common.FingerprintAuth
import CIP56.Token
import Bridge.Contracts
import Bridge.Events

-- =============================================================================
-- WAYFINDER TOKEN METADATA
-- =============================================================================

-- | PROMPT token metadata (CIP-56 compliant)
promptMetadata : ExtendedMetadata
promptMetadata = ExtendedMetadata with
  name = "Wayfinder PROMPT"
  symbol = "PROMPT"
  decimals = 18
  isin = None
  dtiCode = None
  regulatoryInfo = Some "ERC20: 0x28d38df637db75533bd3f71426f3410a82041544"

-- =============================================================================
-- WAYFINDER BRIDGE CONFIG (Issuer-Centric)
-- =============================================================================

-- | Configuration for the Wayfinder Bridge
--
-- The issuer (operator) controls all bridge operations.
-- NOTE: Contract key removed for DAML-LF 2.x compatibility.
template WayfinderBridgeConfig
  with
    issuer : Party                          -- Bridge issuer/operator
    tokenManagerCid : ContractId CIP56Manager
    auditObservers : [Party]                -- Parties who can observe audit events
  where
    signatory issuer
    observer auditObservers

    -- =========================================================================
    -- METADATA
    -- =========================================================================
    
    nonconsuming choice GetMetadata : ExtendedMetadata
      controller issuer
      do pure promptMetadata

    -- =========================================================================
    -- AUDIT OBSERVER MANAGEMENT
    -- =========================================================================

    -- | Add a new audit observer
    choice AddAuditObserver : ContractId WayfinderBridgeConfig
      with
        newObserver : Party
      controller issuer
      do create this with auditObservers = newObserver :: auditObservers

    -- | Remove an audit observer
    choice RemoveAuditObserver : ContractId WayfinderBridgeConfig
      with
        observerToRemove : Party
      controller issuer
      do create this with auditObservers = filter (/= observerToRemove) auditObservers

    -- =========================================================================
    -- PARTY MANAGEMENT (Issuer allocates parties for users)
    -- =========================================================================
    
    -- | Register a user's fingerprint mapping
    --
    -- Called by issuer after allocating a Party for a user:
    -- 1. Issuer calls AllocateParty("UserHint") → "UserHint::1220abc...def"
    -- 2. Issuer extracts fingerprint: "1220abc...def"
    -- 3. Issuer calls this to create the mapping
    nonconsuming choice RegisterUser : ContractId FingerprintMapping
      with
        userParty   : Party         -- The allocated Party
        fingerprint : Text          -- Extracted from Party ID
        evmAddress  : Optional EvmAddress
      controller issuer
      do
        create FingerprintMapping with
          issuer = issuer
          userParty = userParty
          fingerprint = fingerprint
          evmAddress = evmAddress

    -- =========================================================================
    -- DEPOSIT FLOW: EVM → Canton (Fingerprint-Based)
    -- =========================================================================
    
    -- | Create pending deposit from EVM event
    --
    -- Middleware sees DepositToCanton event and calls this.
    -- The fingerprint comes directly from the EVM event (bytes32).
    nonconsuming choice CreatePendingDeposit : ContractId PendingDeposit
      with
        fingerprint : Text          -- From EVM event (bytes32 as hex)
        amount      : Decimal
        evmTxHash   : Text
        timestamp   : Time
      controller issuer
      do
        create PendingDeposit with
          issuer = issuer
          fingerprint = fingerprint
          amount = amount
          evmTxHash = evmTxHash
          tokenId = "PROMPT"
          createdAt = timestamp

    -- | Process deposit and mint tokens with audit event
    --
    -- After creating PendingDeposit, issuer resolves fingerprint and mints.
    -- This is a convenience choice that does everything in one step.
    nonconsuming choice ProcessDepositAndMint : (ContractId CIP56Holding, ContractId BridgeMintEvent)
      with
        depositCid  : ContractId PendingDeposit
        mappingCid  : ContractId FingerprintMapping
        timestamp   : Time          -- Event timestamp
      controller issuer
      do
        -- Process the deposit to get receipt
        receiptCid <- exercise depositCid ProcessDeposit with mappingCid = mappingCid
        receipt <- fetch receiptCid
        
        -- Mint tokens to the resolved recipient
        holdingCid <- exercise tokenManagerCid Mint with
          to = receipt.recipient
          amount = receipt.amount
        
        -- Create audit event
        eventCid <- create BridgeMintEvent with
          issuer = issuer
          recipient = receipt.recipient
          amount = receipt.amount
          holdingCid = holdingCid
          tokenSymbol = promptMetadata.symbol
          evmTxHash = receipt.evmTxHash
          fingerprint = receipt.fingerprint
          timestamp = timestamp
          auditObservers = auditObservers
        
        pure (holdingCid, eventCid)

    -- =========================================================================
    -- WITHDRAWAL FLOW: Canton → EVM
    -- =========================================================================
    
    -- | Initiate withdrawal for a user
    --
    -- User requests withdrawal off-chain (via API/UI).
    -- Issuer creates this to process it.
    nonconsuming choice InitiateWithdrawal : ContractId WithdrawalRequest
      with
        mappingCid      : ContractId FingerprintMapping
        holdingCid      : ContractId CIP56Holding
        amount          : Decimal
        evmDestination  : EvmAddress
      controller issuer
      do
        mapping <- fetch mappingCid
        
        create WithdrawalRequest with
          issuer = issuer
          userParty = mapping.userParty
          tokenManagerCid = tokenManagerCid
          holdingCid = holdingCid
          amount = amount
          evmDestination = evmDestination
          fingerprint = mapping.fingerprint
          tokenSymbol = promptMetadata.symbol
          auditObservers = auditObservers

    -- =========================================================================
    -- DIRECT MINT (Admin/Testing)
    -- =========================================================================
    
    -- | Direct mint to a Party with audit event (bypasses fingerprint lookup)
    --
    -- Use for:
    -- - Testing without fingerprint setup
    -- - Admin operations
    -- - Initial token distribution
    nonconsuming choice DirectMint : (ContractId CIP56Holding, ContractId BridgeMintEvent)
      with
        recipient   : Party
        amount      : Decimal
        evmTxHash   : Text          -- Source EVM transaction (or "admin-mint" for testing)
        fingerprint : Text          -- User fingerprint (or "admin" for testing)
        timestamp   : Time          -- Event timestamp
      controller issuer
      do
        assertMsg "amount > 0" (amount > 0.0)
        
        -- Mint tokens
        holdingCid <- exercise tokenManagerCid Mint with
          to = recipient
          amount = amount
        
        -- Create audit event
        eventCid <- create BridgeMintEvent with
          issuer = issuer
          recipient = recipient
          amount = amount
          holdingCid = holdingCid
          tokenSymbol = promptMetadata.symbol
          evmTxHash = evmTxHash
          fingerprint = fingerprint
          timestamp = timestamp
          auditObservers = auditObservers
        
        pure (holdingCid, eventCid)

    -- =========================================================================
    -- DIRECT TRANSFER (Admin/Testing)
    -- =========================================================================
    
    -- | Direct transfer between parties with audit event
    --
    -- Use for:
    -- - Testing transfers
    -- - Admin operations
    nonconsuming choice DirectTransfer : (Optional (ContractId CIP56Holding), ContractId CIP56Holding, ContractId BridgeTransferEvent)
      with
        senderHoldingCid     : ContractId CIP56Holding
        recipient            : Party
        amount               : Decimal
        senderFingerprint    : Text
        recipientFingerprint : Text
        timestamp            : Time
      controller issuer
      do
        assertMsg "amount > 0" (amount > 0.0)
        senderHolding <- fetch senderHoldingCid
        let sender = senderHolding.owner
        assertMsg "sender has sufficient balance" (senderHolding.amount >= amount)
        
        -- Burn from sender
        senderRemainderCid <- exercise tokenManagerCid Burn with
          holdingCid = senderHoldingCid
          amount = amount
        
        -- Mint to recipient
        recipientHoldingCid <- exercise tokenManagerCid Mint with
          to = recipient
          amount = amount
        
        -- Create transfer audit event
        eventCid <- create BridgeTransferEvent with
          issuer = issuer
          sender = sender
          recipient = recipient
          amount = amount
          senderRemainderCid = senderRemainderCid
          recipientHoldingCid = recipientHoldingCid
          tokenSymbol = promptMetadata.symbol
          senderFingerprint = senderFingerprint
          recipientFingerprint = recipientFingerprint
          timestamp = timestamp
          auditObservers = auditObservers
        
        pure (senderRemainderCid, recipientHoldingCid, eventCid)
