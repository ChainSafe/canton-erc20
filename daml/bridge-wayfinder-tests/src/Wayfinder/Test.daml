-- | Wayfinder Bridge Tests - Issuer-Centric Model
--
-- Tests demonstrating the issuer-centric bridge flow where:
-- - Issuer controls all party allocations and operations
-- - End users do NOT manage Canton keys
-- - Fingerprint resolution is issuer-controlled

module Wayfinder.Test where

import Daml.Script
import DA.Time (time)
import DA.Date (date, Month(..))
import Common.Types
import CIP56.Token
import Bridge.Contracts
import Bridge.Events
import Wayfinder.Bridge

-- =============================================================================
-- ISSUER-CENTRIC FULL FLOW TEST
-- =============================================================================

-- | Complete end-to-end test of issuer-centric bridge with audit events
--
-- Flow:
-- 1. Issuer deploys bridge
-- 2. Issuer allocates parties for users (simulated)
-- 3. Issuer registers fingerprint mappings
-- 4. User deposits on EVM → Issuer processes and mints (with audit event)
-- 5. Issuer initiates withdrawal → Creates events for EVM
testIssuerCentricBridge : Script ()
testIssuerCentricBridge = script do
  -- ===========================================================================
  -- 1. INITIALIZATION
  -- ===========================================================================
  debug ">>> 1. Issuer deploys bridge..."
  
  -- Issuer is the participant node operator
  issuer <- allocateParty "BridgeIssuer"
  auditor <- allocateParty "Auditor"
  
  -- Issuer allocates parties for users
  -- In reality: issuer.partyManagement.allocateParty("Alice") → "Alice::1220abc..."
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  
  -- Deploy token manager
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  -- Deploy bridge config with audit observer
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
      auditObservers = [auditor]
  
  debug "    [OK] Bridge deployed."
  
  -- ===========================================================================
  -- 2. ISSUER REGISTERS USER FINGERPRINTS
  -- ===========================================================================
  debug ">>> 2. Issuer registers fingerprints for Alice and Bob..."
  
  -- When AllocateParty returns party ID, issuer extracts fingerprint
  let aliceFingerprint = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  let bobFingerprint   = "1220bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
  
  -- Register Alice
  aliceMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFingerprint
      evmAddress = Some (EvmAddress "0xAliceEthWallet...")
  
  -- Register Bob
  bobMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = bob
      fingerprint = bobFingerprint
      evmAddress = Some (EvmAddress "0xBobEthWallet...")
  
  debug "    [OK] Users registered with fingerprints."
  
  -- ===========================================================================
  -- 3. DEPOSIT FLOW (EVM → Canton) WITH AUDIT EVENT
  -- ===========================================================================
  debug ">>> 3. Alice deposits 100.0 PROMPT from Ethereum..."
  
  -- Simulate: Middleware sees DepositToCanton event on EVM
  -- bridge.depositToCanton(token, 100e18, bytes32(aliceFingerprint))
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  -- Middleware creates PendingDeposit
  aliceDepositCid <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = aliceFingerprint
      amount = 100.0
      evmTxHash = "0xAliceDepositTx..."
      timestamp = testTime
  
  -- Issuer processes deposit and mints tokens (now returns audit event)
  (aliceHoldingCid, mintEventCid) <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = aliceDepositCid
      mappingCid = aliceMappingCid
      timestamp = testTime
  
  -- Verify Alice received tokens
  Some aliceHolding <- queryContractId alice aliceHoldingCid
  assertMsg "Alice should have 100.0 PROMPT" (aliceHolding.amount == 100.0)
  
  -- Verify mint audit event was created
  Some mintEvent <- queryContractId issuer mintEventCid
  assertMsg "Mint event amount correct" (mintEvent.amount == 100.0)
  assertMsg "Mint event recipient correct" (mintEvent.recipient == alice)
  assertMsg "Mint event fingerprint correct" (mintEvent.fingerprint == aliceFingerprint)
  assertMsg "Mint event tokenSymbol correct" (mintEvent.tokenSymbol == "PROMPT")
  
  -- Verify auditor can see the event
  Some mintEventFromAuditor <- queryContractId auditor mintEventCid
  assertMsg "Auditor can see mint event" (mintEventFromAuditor.amount == 100.0)
  
  debug "    [OK] Alice received 100.0 PROMPT with audit event."
  
  -- ===========================================================================
  -- 4. DIRECT MINT WITH AUDIT EVENT
  -- ===========================================================================
  debug ">>> 4. Direct mint 40.0 PROMPT to Bob..."
  
  let bobMintTime = time (date 2025 Jan 1) 14 0 0
  
  (bobHoldingCid, bobMintEventCid) <- submit issuer do
    exerciseCmd configCid DirectMint with
      recipient = bob
      amount = 40.0
      evmTxHash = "admin-mint"
      fingerprint = bobFingerprint
      timestamp = bobMintTime
  
  Some bobHolding <- queryContractId bob bobHoldingCid
  assertMsg "Bob should have 40.0 PROMPT" (bobHolding.amount == 40.0)
  
  -- Verify Bob's mint event
  Some bobMintEvent <- queryContractId issuer bobMintEventCid
  assertMsg "Bob mint event amount correct" (bobMintEvent.amount == 40.0)
  
  debug "    [OK] Bob has 40.0 PROMPT with audit event."
  
  -- ===========================================================================
  -- 5. WITHDRAWAL FLOW (Canton → EVM) WITH AUDIT EVENT
  -- ===========================================================================
  debug ">>> 5. Bob requests withdrawal of 40.0 PROMPT to Ethereum..."
  
  -- Issuer initiates withdrawal on behalf of Bob
  withdrawalRequestCid <- submit issuer do
    exerciseCmd configCid InitiateWithdrawal with
      mappingCid = bobMappingCid
      holdingCid = bobHoldingCid
      amount = 40.0
      evmDestination = EvmAddress "0xBobEthWallet..."
  
  -- Issuer processes the withdrawal
  let withdrawalTime = time (date 2025 Jan 1) 16 0 0
  (withdrawalEventCid, burnEventCid) <- submit issuer do
    exerciseCmd withdrawalRequestCid ProcessWithdrawal with
      timestamp = withdrawalTime
  
  -- Verify withdrawal event
  Some withdrawalEvent <- queryContractId issuer withdrawalEventCid
  assertMsg "Withdrawal amount correct" (withdrawalEvent.amount == 40.0)
  assertMsg "Withdrawal fingerprint preserved" (withdrawalEvent.fingerprint == bobFingerprint)
  assertMsg "Withdrawal tokenSymbol correct" (withdrawalEvent.tokenSymbol == "PROMPT")
  
  -- Verify burn audit event
  Some burnEvent <- queryContractId issuer burnEventCid
  assertMsg "Burn event amount correct" (burnEvent.amount == 40.0)
  assertMsg "Burn event burnedFrom correct" (burnEvent.burnedFrom == bob)
  assertMsg "Burn event fingerprint correct" (burnEvent.fingerprint == bobFingerprint)
  
  -- Verify auditor can see burn event
  Some burnEventFromAuditor <- queryContractId auditor burnEventCid
  assertMsg "Auditor can see burn event" (burnEventFromAuditor.amount == 40.0)
  
  debug "    [OK] Withdrawal event created with burn audit event."
  
  -- ===========================================================================
  -- 6. COMPLETE WITHDRAWAL (After EVM Release)
  -- ===========================================================================
  debug ">>> 6. Marking withdrawal complete after EVM release..."
  
  completedEventCid <- submit issuer do
    exerciseCmd withdrawalEventCid CompleteWithdrawal with
      evmTxHash = "0xBobEvmReleaseTx..."
  
  Some completedEvent <- queryContractId issuer completedEventCid
  case completedEvent.status of
    Completed txHash -> assertMsg "EVM tx hash recorded" (txHash == "0xBobEvmReleaseTx...")
    _ -> fail "Expected Completed status"
  
  debug "    [OK] Withdrawal marked complete."
  debug ">>> Issuer-Centric Bridge Test with Audit Events Complete!"
  
  pure ()

-- =============================================================================
-- TEST: AUDIT OBSERVER MANAGEMENT
-- =============================================================================

testAuditObserverManagement : Script ()
testAuditObserverManagement = script do
  debug ">>> Testing audit observer management..."
  
  issuer <- allocateParty "BridgeIssuer"
  auditor1 <- allocateParty "Auditor1"
  auditor2 <- allocateParty "Auditor2"
  
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  -- Start with auditor1
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
      auditObservers = [auditor1]
  
  -- Add auditor2
  configCid2 <- submit issuer do
    exerciseCmd configCid AddAuditObserver with
      newObserver = auditor2
  
  -- Verify both auditors are now observers
  Some config <- queryContractId issuer configCid2
  assertMsg "Both auditors should be observers" 
    (auditor1 `elem` config.auditObservers && auditor2 `elem` config.auditObservers)
  
  -- Remove auditor1
  configCid3 <- submit issuer do
    exerciseCmd configCid2 RemoveAuditObserver with
      observerToRemove = auditor1
  
  -- Verify only auditor2 remains
  Some finalConfig <- queryContractId issuer configCid3
  assertMsg "Only auditor2 should remain" 
    (auditor2 `elem` finalConfig.auditObservers && not (auditor1 `elem` finalConfig.auditObservers))
  
  debug "    [OK] Audit observer management works correctly."
  pure ()

-- =============================================================================
-- FINGERPRINT MISMATCH TEST
-- =============================================================================

testFingerprintMismatchRejected : Script ()
testFingerprintMismatchRejected = script do
  debug ">>> Testing fingerprint mismatch rejection..."
  
  issuer <- allocateParty "BridgeIssuer"
  alice <- allocateParty "Alice"
  
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
      auditObservers = []
  
  -- Register Alice with one fingerprint
  let aliceFingerprint = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  aliceMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFingerprint
      evmAddress = None
  
  -- Deposit comes in with DIFFERENT fingerprint
  let wrongFingerprint = "1220cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  depositCid <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = wrongFingerprint
      amount = 50.0
      evmTxHash = "0xWrongDeposit..."
      timestamp = testTime
  
  -- Processing should FAIL
  submitMustFail issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = depositCid
      mappingCid = aliceMappingCid  -- Wrong mapping!
      timestamp = testTime
  
  debug "    [OK] Fingerprint mismatch correctly rejected."
  pure ()

-- =============================================================================
-- MULTIPLE USERS TEST WITH AUDIT EVENTS
-- =============================================================================

testMultipleUsers : Script ()
testMultipleUsers = script do
  debug ">>> Testing multiple users with audit events..."
  
  issuer <- allocateParty "BridgeIssuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  carol <- allocateParty "Carol"
  auditor <- allocateParty "Auditor"
  
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
      auditObservers = [auditor]
  
  -- Register all users
  let aliceFp = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  let bobFp   = "1220bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
  let carolFp = "1220cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"
  
  aliceMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFp
      evmAddress = None
  
  bobMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = bob
      fingerprint = bobFp
      evmAddress = None
  
  carolMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = carol
      fingerprint = carolFp
      evmAddress = None
  
  -- Deposits for each user
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  -- Alice deposits
  aliceDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = aliceFp
      amount = 100.0
      evmTxHash = "0xAlice..."
      timestamp = testTime
  
  (aliceHolding, aliceMintEvent) <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = aliceDeposit
      mappingCid = aliceMapping
      timestamp = testTime
  
  -- Bob deposits
  bobDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = bobFp
      amount = 200.0
      evmTxHash = "0xBob..."
      timestamp = testTime
  
  (bobHolding, bobMintEvent) <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = bobDeposit
      mappingCid = bobMapping
      timestamp = testTime
  
  -- Carol deposits
  carolDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = carolFp
      amount = 300.0
      evmTxHash = "0xCarol..."
      timestamp = testTime
  
  (carolHolding, carolMintEvent) <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = carolDeposit
      mappingCid = carolMapping
      timestamp = testTime
  
  -- Verify all holdings
  Some ah <- queryContractId alice aliceHolding
  Some bh <- queryContractId bob bobHolding
  Some ch <- queryContractId carol carolHolding
  
  assertMsg "Alice amount" (ah.amount == 100.0)
  assertMsg "Bob amount" (bh.amount == 200.0)
  assertMsg "Carol amount" (ch.amount == 300.0)
  
  -- Verify auditor can see all mint events
  Some amFromAuditor <- queryContractId auditor aliceMintEvent
  Some bmFromAuditor <- queryContractId auditor bobMintEvent
  Some cmFromAuditor <- queryContractId auditor carolMintEvent
  
  assertMsg "Auditor sees Alice event" (amFromAuditor.amount == 100.0)
  assertMsg "Auditor sees Bob event" (bmFromAuditor.amount == 200.0)
  assertMsg "Auditor sees Carol event" (cmFromAuditor.amount == 300.0)
  
  debug "    [OK] All users received correct amounts with audit events."
  pure ()
