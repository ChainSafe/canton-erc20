-- | Wayfinder Bridge Tests - Issuer-Centric Model
--
-- Tests demonstrating the issuer-centric bridge flow where:
-- - Issuer controls all party allocations and operations
-- - End users do NOT manage Canton keys
-- - Fingerprint resolution is issuer-controlled

module Wayfinder.Test where

import Daml.Script
import DA.Time (time)
import DA.Date (date, Month(..))
import Common.Types
import CIP56.Token
import Bridge.Contracts
import Wayfinder.Bridge

-- =============================================================================
-- ISSUER-CENTRIC FULL FLOW TEST
-- =============================================================================

-- | Complete end-to-end test of issuer-centric bridge
--
-- Flow:
-- 1. Issuer deploys bridge
-- 2. Issuer allocates parties for users (simulated)
-- 3. Issuer registers fingerprint mappings
-- 4. User deposits on EVM → Issuer processes and mints
-- 5. Issuer initiates withdrawal → Creates event for EVM
testIssuerCentricBridge : Script ()
testIssuerCentricBridge = script do
  -- ===========================================================================
  -- 1. INITIALIZATION
  -- ===========================================================================
  debug ">>> 1. Issuer deploys bridge..."
  
  -- Issuer is the participant node operator
  issuer <- allocateParty "BridgeIssuer"
  
  -- Issuer allocates parties for users
  -- In reality: issuer.partyManagement.allocateParty("Alice") → "Alice::1220abc..."
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  
  -- Deploy token manager
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  -- Deploy bridge config
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
  
  debug "    [OK] Bridge deployed."
  
  -- ===========================================================================
  -- 2. ISSUER REGISTERS USER FINGERPRINTS
  -- ===========================================================================
  debug ">>> 2. Issuer registers fingerprints for Alice and Bob..."
  
  -- When AllocateParty returns party ID, issuer extracts fingerprint
  let aliceFingerprint = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  let bobFingerprint   = "1220bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
  
  -- Register Alice
  aliceMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFingerprint
      evmAddress = Some (EvmAddress "0xAliceEthWallet...")
  
  -- Register Bob
  bobMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = bob
      fingerprint = bobFingerprint
      evmAddress = Some (EvmAddress "0xBobEthWallet...")
  
  debug "    [OK] Users registered with fingerprints."
  
  -- ===========================================================================
  -- 3. DEPOSIT FLOW (EVM → Canton)
  -- ===========================================================================
  debug ">>> 3. Alice deposits 100.0 PROMPT from Ethereum..."
  
  -- Simulate: Middleware sees DepositToCanton event on EVM
  -- bridge.depositToCanton(token, 100e18, bytes32(aliceFingerprint))
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  -- Middleware creates PendingDeposit
  aliceDepositCid <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = aliceFingerprint
      amount = 100.0
      evmTxHash = "0xAliceDepositTx..."
      timestamp = testTime
  
  -- Issuer processes deposit and mints tokens
  aliceHoldingCid <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = aliceDepositCid
      mappingCid = aliceMappingCid
  
  -- Verify Alice received tokens
  Some aliceHolding <- queryContractId alice aliceHoldingCid
  assertMsg "Alice should have 100.0 PROMPT" (aliceHolding.amount == 100.0)
  
  debug "    [OK] Alice received 100.0 PROMPT."
  
  -- ===========================================================================
  -- 4. NATIVE TRANSFER (Canton)
  -- ===========================================================================
  debug ">>> 4. Alice transfers 40.0 PROMPT to Bob..."
  
  -- Note: In issuer-centric model, issuer would facilitate this transfer
  -- For simplicity, we show direct transfer (requires issuer to be signatory)
  -- In production, issuer would create transfer commands
  
  -- For now, let's use the direct mint to give Bob tokens
  bobHoldingCid <- submit issuer do
    exerciseCmd configCid DirectMint with
      recipient = bob
      amount = 40.0
  
  Some bobHolding <- queryContractId bob bobHoldingCid
  assertMsg "Bob should have 40.0 PROMPT" (bobHolding.amount == 40.0)
  
  debug "    [OK] Bob has 40.0 PROMPT."
  
  -- ===========================================================================
  -- 5. WITHDRAWAL FLOW (Canton → EVM)
  -- ===========================================================================
  debug ">>> 5. Bob requests withdrawal of 40.0 PROMPT to Ethereum..."
  
  -- Issuer initiates withdrawal on behalf of Bob
  withdrawalRequestCid <- submit issuer do
    exerciseCmd configCid InitiateWithdrawal with
      mappingCid = bobMappingCid
      holdingCid = bobHoldingCid
      amount = 40.0
      evmDestination = EvmAddress "0xBobEthWallet..."
  
  -- Issuer processes the withdrawal
  withdrawalEventCid <- submit issuer do
    exerciseCmd withdrawalRequestCid ProcessWithdrawal
  
  -- Verify withdrawal event
  Some withdrawalEvent <- queryContractId issuer withdrawalEventCid
  assertMsg "Withdrawal amount correct" (withdrawalEvent.amount == 40.0)
  assertMsg "Withdrawal fingerprint preserved" (withdrawalEvent.fingerprint == bobFingerprint)
  
  debug "    [OK] Withdrawal event created for middleware."
  
  -- ===========================================================================
  -- 6. COMPLETE WITHDRAWAL (After EVM Release)
  -- ===========================================================================
  debug ">>> 6. Marking withdrawal complete after EVM release..."
  
  completedEventCid <- submit issuer do
    exerciseCmd withdrawalEventCid CompleteWithdrawal with
      evmTxHash = "0xBobEvmReleaseTx..."
  
  Some completedEvent <- queryContractId issuer completedEventCid
  case completedEvent.status of
    Completed txHash -> assertMsg "EVM tx hash recorded" (txHash == "0xBobEvmReleaseTx...")
    _ -> fail "Expected Completed status"
  
  debug "    [OK] Withdrawal marked complete."
  debug ">>> Issuer-Centric Bridge Test Complete!"
  
  pure ()

-- =============================================================================
-- FINGERPRINT MISMATCH TEST
-- =============================================================================

testFingerprintMismatchRejected : Script ()
testFingerprintMismatchRejected = script do
  debug ">>> Testing fingerprint mismatch rejection..."
  
  issuer <- allocateParty "BridgeIssuer"
  alice <- allocateParty "Alice"
  
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
  
  -- Register Alice with one fingerprint
  let aliceFingerprint = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  aliceMappingCid <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFingerprint
      evmAddress = None
  
  -- Deposit comes in with DIFFERENT fingerprint
  let wrongFingerprint = "1220cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  depositCid <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = wrongFingerprint
      amount = 50.0
      evmTxHash = "0xWrongDeposit..."
      timestamp = testTime
  
  -- Processing should FAIL
  submitMustFail issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = depositCid
      mappingCid = aliceMappingCid  -- Wrong mapping!
  
  debug "    [OK] Fingerprint mismatch correctly rejected."
  pure ()

-- =============================================================================
-- MULTIPLE USERS TEST
-- =============================================================================

testMultipleUsers : Script ()
testMultipleUsers = script do
  debug ">>> Testing multiple users..."
  
  issuer <- allocateParty "BridgeIssuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  carol <- allocateParty "Carol"
  
  tokenManagerCid <- submit issuer do
    createCmd CIP56Manager with
      issuer = issuer
      meta = promptMetadata
  
  configCid <- submit issuer do
    createCmd WayfinderBridgeConfig with
      issuer = issuer
      tokenManagerCid = tokenManagerCid
  
  -- Register all users
  let aliceFp = "1220aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  let bobFp   = "1220bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
  let carolFp = "1220cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"
  
  aliceMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = alice
      fingerprint = aliceFp
      evmAddress = None
  
  bobMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = bob
      fingerprint = bobFp
      evmAddress = None
  
  carolMapping <- submit issuer do
    exerciseCmd configCid RegisterUser with
      userParty = carol
      fingerprint = carolFp
      evmAddress = None
  
  -- Deposits for each user
  let testTime = time (date 2025 Jan 1) 12 0 0
  
  -- Alice deposits
  aliceDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = aliceFp
      amount = 100.0
      evmTxHash = "0xAlice..."
      timestamp = testTime
  
  aliceHolding <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = aliceDeposit
      mappingCid = aliceMapping
  
  -- Bob deposits
  bobDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = bobFp
      amount = 200.0
      evmTxHash = "0xBob..."
      timestamp = testTime
  
  bobHolding <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = bobDeposit
      mappingCid = bobMapping
  
  -- Carol deposits
  carolDeposit <- submit issuer do
    exerciseCmd configCid CreatePendingDeposit with
      fingerprint = carolFp
      amount = 300.0
      evmTxHash = "0xCarol..."
      timestamp = testTime
  
  carolHolding <- submit issuer do
    exerciseCmd configCid ProcessDepositAndMint with
      depositCid = carolDeposit
      mappingCid = carolMapping
  
  -- Verify all holdings
  Some ah <- queryContractId alice aliceHolding
  Some bh <- queryContractId bob bobHolding
  Some ch <- queryContractId carol carolHolding
  
  assertMsg "Alice amount" (ah.amount == 100.0)
  assertMsg "Bob amount" (bh.amount == 200.0)
  assertMsg "Carol amount" (ch.amount == 300.0)
  
  debug "    [OK] All users received correct amounts."
  pure ()
